package com.loserico.java8.stream;

import org.junit.Test;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import static java.util.stream.Collectors.toList;
import static org.apache.commons.lang3.StringUtils.isNotBlank;

public class StreamArraysTest {

	@Test
	public void testArray2Stream() {
		String[] array = {"a", "b", "c", "d", "e"};
		Stream<String> stream = Arrays.stream(array);
		stream.forEach(System.out::println);
		
		System.out.println("---------");
		
		Stream<String> stream2 = Stream.of(array);
		stream2.forEach(System.out::println);
	}
	
	@Test
	public void testGetStreamFromArray() {
		Stream<Integer> stream = Stream.of(1, 2, 3, 4, 5, 6);
		Stream<Integer> stream2 = Arrays.stream(new Integer[] { 1, 2, 3, 4, 5, 6 });
		Stream<Integer> stream3 = Arrays.asList(1, 2, 3, 4, 5, 6).stream();
	}

	/**
	 * Once we have a stream all stream features are available, for example to filter
	 * empty strings from an array of Strings:
	 */
	@Test
	public void testGetArrayBack() {
		Stream.of("a", "", "b", "", "c", "")
				.filter(s -> isNotBlank(s))
				.forEach(System.out::println);

		System.out.println("--------------");

		List<String> list = Stream.of("a", "", "b", "", "c", "")
				.filter(s -> isNotBlank(s))
				.collect(toList());
		String[] array = list.toArray(new String[list.size()]);
		for (int i = 0; i < array.length; i++) {
			String s = array[i];
			System.out.println(s);
		}

		System.out.println("---------------------");

		/*
		 * I was almost about to implement a custom array collector to eliminate the
		 * extra step. Until I discovered that there is a terminal operation to
		 * capture the result of a stream into an array as simple as that:
		 */
		String[] array2 = Stream.of("a", "", "b", "", "c", "")
				.filter(s -> isNotBlank(s))
				.toArray(size -> new String[size]); //Stream直接到数组String[]
		for (int i = 0; i < array2.length; i++) {
			String s = array2[i];
			System.out.println(s);
		}

		System.out.println("---------------------");

		/*
		 * toArray() requires a generator, a reference to a method that is able to
		 * create an array of the requested size. Here an array of type String is
		 * created. But wait, there is an even simpler way. As mentioned above, the
		 * generator is a function that can create an array of a requested size. And
		 * the makers of Java 8 were so kind to introduce some syntactic sugar to
		 * directly reference an array constructor. By adding an opening and closing
		 * square bracket to a constructor reference, an array constructor reference
		 * can be expressed, e.g. Type[]::new.. Hence the above line can be rewritten
		 * like so:
		 * 
		 * The String[]::new expression is expanded to size -> new String[ size ] by
		 * the compiler. And therefore the generated byte code is the same as with the
		 * previous approach but I find the latter much more concise.
		 */
		String[] array3 = Stream.of("a", "", "b", "", "c", "")
				.filter(s -> isNotBlank(s))
				.toArray(String[]::new); ////Stream直接到数组String[]
		for (int i = 0; i < array3.length; i++) {
			String s = array3[i];
			System.out.println(s);
		}
	}

	@Test
	public void testConvertPrimativeArrayToList() {
		int[] number = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

		// IntStream.of or Arrays.stream, same output
		List<Integer> list1 = IntStream.of(number).boxed().collect(Collectors.toList());
		System.out.println("list1 : " + list1);

		List<Integer> list2 = Arrays.stream(number).boxed().collect(toList());
		System.out.println("list2 : " + list2);
	}
}
